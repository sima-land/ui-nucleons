# Разработка компонентов интерфейса

При разработке многократно используемых компонентов интерфейса необходимо учитывать множество нюансов.

Рекомендации разработки таких компонентов представлены в этом документе.

### Общее

- Компонент интерфейса не должен иметь внешних отступов (margin) по умолчанию
- Ref'ы должны передаваться от родительских к дочерним компонентам только для заполнения, не надо делать компонент таким образом чтобы он ожидал заполненный чем-либо ref в качестве пропса
- Основные элементы в составе компонента должны быть размечены атрибутами `data-testid`
- Стоит фиксировать внешний вид компонента на мобильных разрешениях (например e2e-тестами или на витрине компонентов)
- Стоит фиксировать работу компонента на мобильных устройствах с touch-экранами
- Как можно меньше побочных эффектов делаем по умолчанию: `<Modal withBodyScrollLock />` лучше чем `<Modal />`

### Доступность (Accessibility)

По закону Парето для определения уровня доступности компонента можно ответить всего на пару вопросов:

- Компонент хорошо виден пользователям с проблемами со зрением? (например фокус выделяется заметной рамкой)
- Компонент реагирует на ввод с клавиатуры? (полноценная работа с компонентом должна быть возможна на компьютере без мыши)

### Удобство в разработке (DX)

- Классовым компонентам предпочитаем функциональные компоненты и хуки
- Избегаем `forwardRef` для проброса элементов (часто лучше дать специальное имя, например `inputRef`)
- Компонент больше 200 строк - повод задуматься о декомпозиции

### Unit-тестирование

- Поиск элемента по атрибуту `data-testid` лучше поиска по CSS-классу
- Избегаем использование snaphshot'ов VDOM так как внутреннее устройство компонента - это деталь реализации
- Избегаем использование snaphshot'ов VDOM так как пропсы компонентов могут быть рекурсивными объектами
- Избегаем использование snaphshot'ов DOM так как они сильно связывают компоненты между собой

### E2E-Тестирование

1. Локально E2E-тесты должны запускаться в Docker-контейнере, пример:

```sh
docker run --rm --network host -v $(pwd):/work/ -w /work/ -it mcr.microsoft.com/playwright:v1.37.0-jammy /bin/bash
npx playwright test

# совет: на linux для запуска тестов которе используют host.docker.internal можно добавить:
# --add-host=host.docker.internal:host-gateway
```

В противном случае скриншотные тесты не будут совпадать из-за разницы окружения запуска.

2. Приемочные тесты по максимуму должны быть автономными поэтому лучше не ссылаться на внешние ресурсы (стили, шрифты, скрипты и тд) в тестируемых приложениях.

### Кастомизация

Компонент может поддерживать свойства, отвечающие за предусмотренные варианты стилизации.

Пример кода такого компонента:

```scss
// my-component.module.scss
.size-s {
  height: 32px;
}

.size-m {
  height: 48px;
}
```

```tsx
// my-component.tsx
import classNames from 'classNames/bind';
import styles from './my-component.module.scss';

interface MyComponentProps {
  size?: 's' | 'm';
  className?: string;
}

const cx = classNames.bind(styles);

export function MyComponent({ size, className }: MyComponentProps) {
  return <div className={cx(`size-${size}`, className)}>My Component</div>;
}
```

Стилизация может зависеть от медиа-выражений. Библиотека предоставляет хуки `useMedia` и `useBreakpoint`, но бывает необходимо вывести компонент в начальной верстке страницы (SSG, SSR) до запуска JS в браузере.

Для решения этой задачи можно использовать следующий подход:

1. Добавить scss-миксин для каждого варианта стилизации:

   ```scss
   // my-component-util.scss
   @mixin size-s {
     height: 32px;
   }

   @mixin size-m {
     height: 48px;
   }
   ```

1. Задействовать эти миксины при указании соответствующих значений:

   ```scss
   // my-component.module.scss
   @use './my-component-util.scss';

   .size-s {
     @include my-component-util.size-s;
   }

   .size-m {
     @include my-component-util.size-m;
   }
   ```

1. Дополнить тип свойства новым значением `unset`, которое отключает использование scss-миксинов:

   ```tsx
   interface MyComponentProps {
     size?: 's' | 'm' | 'unset';
     className?: string;
   }
   ```

1. Сделать scss-миксины доступными для использования за пределами исходного кода компонента.

Таким образом в проекте, который использует `MyComponent`, можно поступить следующим образом:

```tsx
<MyComponent size='unset' className='custom'>
```

```scss
@use '~/my-component/my-component-util';

.custom {
  @include my-component-utils.size-s;
}

@media (min-width: 480px) {
  .custom {
    @include my-component-utils.size-m;
  }
}
```
